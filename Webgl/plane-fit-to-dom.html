<html>
    <head>
        <title>first three.js app</title>
        <style>
            body {
                margin: 0;
            }

            img {
                position: absolute;
                left: 0; top:0;

                width: 50%;
                left: 25%;
                top:50%;
                transform: translate3d(0,-50%,0);
                opacity: 0;
            }
        </style>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/97/three.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.3/dat.gui.min.js"></script>
    </head>
    <body>
        <img src="./textures/gallery/sand_for_polygon.jpg" class="img" id="image" alt="">
        <script>

            let scene   = new THREE.Scene();
            let camera  = new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,0.1,5000);

            let renderer = new THREE.WebGLRenderer();
            let aspect = window.innerWidth / window.innerHeight;
            renderer.setSize(window.innerWidth,window.innerHeight);
            document.body.appendChild(renderer.domElement);

            let img = document.getElementById('image');
            let texture = new THREE.TextureLoader().load(img.getAttribute('src'));

            let geo = new THREE.PlaneGeometry(img.width,img.height,1);
            let mat = new THREE.MeshBasicMaterial({map:texture});
            let mesh = new THREE.Mesh(geo,mat);
            geo.computeBoundingBox();
            scene.add(mesh);

            camera.position.z = 1;

            let gui = new dat.GUI();
            var guiF = gui.addFolder('camera');
            guiF.add(camera.position,'x',-1000,1000);
            guiF.add(camera.position,'y',-1000,1000);
            guiF.add(camera.position,'z',-1000,1000);

            var guiF = gui.addFolder('plane');
            guiF.add(mesh.position,'x',-5000,1000);
            guiF.add(mesh.position,'y',-5000,1000);
            guiF.add(mesh.position,'z',-5000,1000);

            let render = function(){
                requestAnimationFrame(render);
                renderer.render(scene, camera);
            }

            let vFov = camera.fov * Math.PI / 180;



            window.addEventListener('resize',resize);

            function resize(){
                aspect = window.innerWidth / window.innerHeight;
                camera.aspect = aspect;
                renderer.setSize(window.innerWidth,window.innerHeight);
                camera.updateProjectionMatrix();

                setZ();
            }

            function setZ(){
                var rect = img.getBoundingClientRect();
                newPosition = computeZ(mesh,camera,img,rect.height);
                mesh.position.z = -newPosition.z;    
            }

            resize();
            render();

            function computeZ(mesh,camera,targetDom,targetHeight){
                mesh.geometry.computeBoundingBox();
                var face = mesh.geometry.vertices[0];
                var faceHeight = mesh.geometry.boundingBox.max.y-mesh.geometry.boundingBox.min.y;
                var vFOV = camera.fov * Math.PI / 180;  
                var vHeightPartial = 2 * Math.tan( vFOV / 2 );
                var p1 = faceHeight * window.innerHeight;
                var p2 = face.z * vHeightPartial;
                var p3 = targetHeight * vHeightPartial;
                var p4 = targetHeight * p2;
                var p5 = p1 + p4;
                var z = p5/p3;
          
                //calculate dom element center coordinate
                var screenPositionX = 0;
                var screenPositionY = 0;
                var divDim = targetDom.getBoundingClientRect();
                screenPositionX = (divDim.left + divDim.right) / 2;
                screenPositionY = (divDim.bottom + divDim.top) / 2;
                var vector = new THREE.Vector3((screenPositionX / window.innerWidth) * 2 -1, (screenPositionY / window.innerHeight) * 2 -1, 0.5);

                //unproject camera
                vector = vector.unproject(camera);
                var distanceZ = camera.position.z - vector.z ;
                var offsetX = vector.x * (z-10) / distanceZ;
                var offsetY = vector.y * (z-10) / distanceZ;
                var cameraPosition = new THREE.Vector3(offsetX,offsetY,z);
                return cameraPosition;
            }

            function computeX(){
                var div = document.getElementById('box');
                var divDim = div.getBoundingClientRect();
                var y =  ((divDim.left + (targetWidth/2)) / window.innerHeight ) * 2 + 1;
                return y;
            }
          
            function computeY(){
                var div = document.getElementById('box');
                var divDim = div.getBoundingClientRect();
                var y =  ((divDim.top + (targetHeight/2)) / window.innerHeight ) * 2 + 1;
                return y;
            }
        </script>

        
    </body>
</html>