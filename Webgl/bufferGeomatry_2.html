<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        width:100%; height:100%;
        background-color: #fff;
        margin:0 auto;
        overflow: hidden;
      }
    </style>
    <script src="build/three.min.js"></script>
  </head>
  <body>
    
    <script>
      var camera,renderer,scene;
      var width,height,halfWidth,halfHeight,aspect;
      var config = {
        fov:45,
        near:1,
        far:10000
      };
      var mouse = {x:0,y:0};
      var wheel = {x:0,y:0,ox:0,oy:0};
      var renderID;

      var texure;
      var meshs = [];
      function setup(){
        aspect  = window.innerWidth/window.innerHeight;
        scene   = new THREE.Scene();
        camera  = new THREE.PerspectiveCamera(config.fov,aspect,config.near,config.far);
        renderer = new THREE.WebGLRenderer({});
        renderer.setClearColor(0x000000,0);
        camera.position.z = 2000;


        renderer.setSize(window.innerWidth,window.innerHeight);
        document.body.appendChild(renderer.domElement);
        onResize();

        texure = new THREE.TextureLoader().load('textures/hollywood.jpg',function(){setBG()});
        addEvent();
        makeBufferGeo();
      }

      function addEvent(){
        document.addEventListener( 'mousemove', onMouseMove, false );
        window.addEventListener( 'resize', onResize, false );
        document.addEventListener( 'mousewheel', onScroll);
      }

      function setBG(){
        return;
        var geomarty,material,mesh;
        var w = texure.image.width, h = texure.image.height;
        geomarty  = new THREE.PlaneGeometry(1,h/w,1,1);
        material  = new THREE.MeshBasicMaterial({map:texure});
        mesh      = new THREE.Mesh(geomarty,material);
        mesh.position.z = 100;
        mesh.scale.x = mesh.scale.y = 600;
        scene.add(mesh);
      }

      function makeBufferGeo(){
        var light1 = new THREE.DirectionalLight( 0xffffff, 0.5 );
        light1.position.set( 1, 1, 1 );
        scene.add( light1 );

        var light2 = new THREE.DirectionalLight( 0xffffff, 1.5 );
        light2.position.set( 0, -1, 0 );
        scene.add( light2 );

        var triangles = 10000;
        var geometry = new THREE.BufferGeometry();
        var indices = new Uint32Array( triangles * 3 );

        for ( var i = 0; i < indices.length; i ++ ) {
          indices[ i ] = i;
        }
        var positions = new Float32Array( triangles * 3 * 3 );
        var normals = new Int16Array( triangles * 3 * 3 );
        var colors = new Uint8Array( triangles * 3 * 3 );

        var color = new THREE.Color();
        var n = 300, n2 = n/2;  // triangles spread in the cube
        var d = 12, d2 = d/2; // individual triangle size

        var pA = new THREE.Vector3();
        var pB = new THREE.Vector3();
        var pC = new THREE.Vector3();

        var cb = new THREE.Vector3();
        var ab = new THREE.Vector3();

        for ( var i = 0; i < positions.length; i += 9 ) {
          
          /* ************************************************************
            Position Set
          ************************************************************ */
          
          var x = Math.random() * n - n2;
          var y = Math.random() * n - n2;
          var z = i*0.1;
 
          //vertex1
          var ax = x + Math.random() * d - d2;
          var ay = y + Math.random() * d - d2;
          var az = z + Math.random() * d - d2;

          //vertex2
          var bx = x + Math.random() * d - d2;
          var by = y + Math.random() * d - d2;
          var bz = z + Math.random() * d - d2;

          //vertex3
          var cx = x + Math.random() * d - d2;
          var cy = y + Math.random() * d - d2;
          var cz = z + Math.random() * d - d2;

          //vertex1
          positions[ i ]     = ax;
          positions[ i + 1 ] = ay;
          positions[ i + 2 ] = az;

          //vertex2
          positions[ i + 3 ] = bx;
          positions[ i + 4 ] = by;
          positions[ i + 5 ] = bz;

          //vertex3
          positions[ i + 6 ] = cx;
          positions[ i + 7 ] = cy;
          positions[ i + 8 ] = cz;

          // flat face normals
          pA.set( ax, ay, az );
          pB.set( bx, by, bz );
          pC.set( cx, cy, cz );


          /* ************************************************************
            normals Set
          ************************************************************ */

          cb.subVectors( pC, pB );
          ab.subVectors( pA, pB );
          cb.cross( ab );
          cb.normalize();

          var nx = cb.x;
          var ny = cb.y;
          var nz = cb.z;

          normals[ i ]     = nx * 32767;
          normals[ i + 1 ] = ny * 32767;
          normals[ i + 2 ] = nz * 32767;
          normals[ i + 3 ] = nx * 32767;
          normals[ i + 4 ] = ny * 32767;
          normals[ i + 5 ] = nz * 32767;
          normals[ i + 6 ] = nx * 32767;
          normals[ i + 7 ] = ny * 32767;
          normals[ i + 8 ] = nz * 32767;
          // colors
          var vx = ( x / n ) + 0.5;
          var vy = ( y / n ) + 0.5;
          var vz = ( z / n ) + 0.5;
          color.setRGB( vx, vy, vz );
          colors[ i ]     = color.r * 255;
          colors[ i + 1 ] = color.g * 255;
          colors[ i + 2 ] = color.b * 255;
          colors[ i + 3 ] = color.r * 255;
          colors[ i + 4 ] = color.g * 255;
          colors[ i + 5 ] = color.b * 255;
          colors[ i + 6 ] = color.r * 255;
          colors[ i + 7 ] = color.g * 255;
          colors[ i + 8 ] = color.b * 255;
        }
        geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
        geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
        geometry.addAttribute( 'normal', new THREE.BufferAttribute( normals, 3, true ) );
        geometry.addAttribute( 'color', new THREE.BufferAttribute( colors, 3, true ) );
        geometry.computeBoundingSphere();
        var material = new THREE.MeshPhongMaterial( {
          color: 0xaaaaaa, specular: 0xffffff, shininess: 250,
          side: THREE.DoubleSide, vertexColors: THREE.VertexColors
        } );
        mesh = new THREE.Mesh( geometry, material );
        scene.add( mesh );

      }
      /* ************************************************************
        Renering and Animation
      ************************************************************ */
      function animation(){
        var time = Date.now() * 0.001;
        wheel.y *= 0.95;
      }

      function render(){
        camera.position.x += ( mouse.x - camera.position.x ) * 0.05;
        camera.position.y += ( - mouse.y - camera.position.y ) * 0.05;
        camera.position.z += wheel.y*0.01;
        camera.lookAt( scene.position );
        renderer.render( scene, camera );
      }

      function update(){
        animation();
        render();
        renderID = requestAnimationFrame( update );
      }

      /* ************************************************************
          EVENT HANDLER
      ************************************************************ */
      function onResize(){
        width   = window.innerWidth;
        height  = window.innerHeight;
        halfWidth = width*0.5;
        halfHeight = height*0.5;
        aspect  = width/height;
        
        camera.aspect = width/height;
        renderer.setSize(width,height);
        camera.updateProjectionMatrix();
      }

      function onMouseMove( e ) {
        mouse.x = ( e.clientX - halfWidth );
        mouse.y = ( e.clientY - halfHeight );
      }

      function onScroll(e){
        wheel.y += e.deltaY;
      }


      
      requestAnimationFrame( update );
      setup();
      update();

    </script>
  </body>
</html>
