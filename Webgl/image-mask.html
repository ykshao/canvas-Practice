<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
      body {
        position: absolute;
        width: 100%; height:100%;
        background-color: #fff;
        margin:0 auto;
        overflow: hidden;
      }

    </style>
    <script src="build/three.min.js"></script>
  </head>
  <body>
    
    <script>
      var camera,renderer,scene;
      var width,height,aspect;
      var config = {
        fov:45,
        near:1,
        far:10000
      }
      var mouse = {x:0,y:0};
      var renderID;

      var texture;
      var cube_count,
          meshes = [],
          materials = [],
          xgrid = 20,
          ygrid = 10;

      function setup(){
        aspect  = window.innerWidth/window.innerHeight;
        scene   = new THREE.Scene();
        camera  = new THREE.PerspectiveCamera(config.fov,aspect,config.near,config.far);
        renderer = new THREE.WebGLRenderer({});
        renderer.setClearColor(0xffffff,0);
        camera.position.z = 500;

        var light = new THREE.DirectionalLight( 0xffffff );
        light.position.set( 0.5, 1, 1 ).normalize();
        scene.add( light );

        renderer.setSize(window.innerWidth,window.innerHeight);
        document.body.appendChild(renderer.domElement);
        onResize();
        addEvent();

        texture = new THREE.TextureLoader().load('textures/gallery/hollywood.jpg',function(){setBG()});

      }

      function setBG(){
        // var geomarty,material,mesh;
        // geomarty  = new THREE.PlaneGeometry(texture.image.width/texture.image.height*10,10,11,11);
        // material  = new THREE.MeshBasicMaterial({map:texture,wireframe:false});
        // mesh      = new THREE.Mesh(geomarty,material);
        // mesh.position.z = 1;
        // scene.add(mesh);

        var i, j, ux, uy, ox, oy, geometry, xsize, ysize;
        ux = 1 / xgrid;
        uy = 1 / ygrid;
        xsize = texture.image.width*0.2 / xgrid;
        ysize = texture.image.height*0.2 / ygrid;

        var parameters = { color: 0xffffff, map: texture};

        cube_count = 0;
        for ( i = 0; i < xgrid; i ++ )
        for ( j = 0; j < ygrid; j ++ ) {

          ox = i;
          oy = j;

          geometry = new THREE.PlaneGeometry( xsize, ysize, xsize );
          change_uvs( geometry, ux, uy, ox, oy );

          materials[ cube_count ] = new THREE.MeshBasicMaterial( parameters );

          material = materials[ cube_count ];
          // console.log(material)
          material.side = THREE.DoubleSide;


          // material.hue = i/xgrid;
          // material.saturation = 1 - j/ygrid;
          // material.color.setHSL( material.hue, material.saturation, 0.5 );


          mesh = new THREE.Mesh( geometry, material );

          mesh.position.x =   ( i - xgrid/2 ) * xsize;
          mesh.position.y =   ( j - ygrid/2 ) * ysize;
          mesh.position.z = 0;

          mesh.scale.x = mesh.scale.y = mesh.scale.z = 1;

          scene.add( mesh );

          mesh.dx = 0.001 * ( 0.5 - Math.random() );
          mesh.dy = 0.001 * ( 0.5 - Math.random() );

          meshes[ cube_count ] = mesh;

          cube_count += 1;

        }
      }

      function addEvent(){
        document.addEventListener( 'mousemove', onMouseMove, false );
        window.addEventListener( 'resize', onResize, false );
        document.body.addEventListener( 'scroll', onScroll);
      }

      function change_uvs( geometry, unitx, unity, offsetx, offsety ) {
        var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
        for ( var i = 0; i < faceVertexUvs.length; i ++ ) {
          var uvs = faceVertexUvs[ i ];
          for ( var j = 0; j < uvs.length; j ++ ) {
            var uv = uvs[ j ];
            uv.x = ( uv.x + offsetx ) * unitx;
            uv.y = ( uv.y + offsety ) * unity;
          }
        }
      }


      function onResize(){
        width   = window.innerWidth;
        height  = window.innerHeight;
        aspect  = width/height;
        
        camera.aspect = width/height;
        renderer.setSize(width,height);
        camera.updateProjectionMatrix();
      }

      function onMouseMove( e ) {
        mouse.x = ( e.clientX - width*0.5 );
        mouse.y = ( e.clientY - height*0.5 );
      }

      function onScroll(e){
        console.log('e');
      }

      function animation(){
        var time = Date.now() * 0.001;

        for ( i = 0; i < cube_count; i ++ ) {
            mesh = meshes[ i ];
            mesh.rotation.x += 10 * mesh.dx;
            mesh.rotation.y += 10 * mesh.dy;

            // mesh.position.x += (mouse.x-mesh.position.x) * mesh.dx;
            // mesh.position.y += (-mouse.y-mesh.position.y) * mesh.dy;
            // mesh.position.y += 200 * mesh.dy;
            // mesh.position.x += camera.position.x*mesh.dx;
            // mesh.position.y += camera.position.y*mesh.dy;
            // mesh.position.z += camera.position.x*mesh.dx;

          }
      }

      var time;
      function render(){
        camera.position.x += ( mouse.x - camera.position.x ) * 0.05;
        camera.position.y += ( - mouse.y - camera.position.y ) * 0.05;
        camera.lookAt( scene.position );
        renderer.render( scene, camera );
      }

      function update(){
        animation();
        render();
        renderID = requestAnimationFrame( update );
      }
      requestAnimationFrame( update );


      setup();
      update();

    </script>
  </body>
</html>
