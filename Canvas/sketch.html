<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="initial-scale=1">
        <meta name="description" content="">
        <title></title>
        <link rel="stylesheet" href="css/normalize.css">
        <style>
            body {
                background-color: #fff4ed;
                width: 100%; height: 100%;
                overflow: hidden;
            }

            #wrap{
                position: absolute;
                width: 648px;
                height: 382px;
                left:50%; margin-left: -324px;
                top:50%; margin-top: -192px;
                background-color: #000;

            }

            #img-color {
                position: absolute;
                /*left:300px;*/
                /*top:200px;*/
            }   

            #canvasWrap,#canvasWrap2 {
                position: absolute;
            }

        </style>
        <script src="js/jquery-1.10.2.min.js"></script>
        <script src="js/jquery.easing.1.3.js"></script>
        <script src="js/canvas.js"></script>
        <script src="js/effect.powder.js"></script>

        <script>
            $(document).ready(function(){
                var canvas  = new Canvas('#canvasWrap',0,1280,800),
                    ctx     = canvas.getContext();

                var canvas2  = new Canvas('#canvasWrap2',1,1280,800),
                    ctx2     = canvas2.getContext();

                var drawImg = new Image();
                drawImg.src = 'img/img1-sketch.png';

                var brush = new Image();
                brush.src = 'img/brush2.png';
                var brushSize = 80;

                var drawPoints = [],standP = {x:100,y:100};
                $("#img-color").css({left:standP.x,top:standP.y});
                drawImg.onload = function(){
                    var width   = drawImg.width,
                        height  = drawImg.height;

                    var startP = {x:0,y:0},
                        lastP  = {x:width,y:height},
                        dist   = {x:startP.x-lastP.x, y: startP.y-lastP.y};

                    // drawRect(startP.x+300,startP.y+200,width,height);

                    var diagonal = parseInt(Math.sqrt(dist.x*dist.x+dist.y*dist.y));
                    var brushDis = (width+height)/brushSize;

                    var points1 = [],bendPoint1 = {start:0,cnt:0,x:0,y:0},
                        points2 = [],bendPoint2 = {start:0,cnt:0,x:0,y:0},
                        cnt=0;

                    for(var i=0,n=brushDis; i<n; i++){
                        var x = 0,
                            y = i * brushSize;

                        if(y > height){
                            bendPoint1.start = i-bendPoint1.cnt;
                            x = bendPoint1.cnt * brushSize;
                            y = bendPoint1.start * brushSize;
                            bendPoint1.cnt++;
                        }

                        points1.push({x:x + standP.x - brushSize*0.5 ,y: y + standP.y + brushSize*0.5});
                        // drawPoint(points1[i].x,points1[i].y);
                    }

                    for(var i=0,n=brushDis; i<n; i++){
                        var x = i * brushSize,
                            y = 0;

                        if(x > width){
                            bendPoint2.start = i-bendPoint2.cnt;
                            x = bendPoint2.start * brushSize;
                            y = bendPoint2.cnt * brushSize;
                            bendPoint2.cnt++;
                        }

                        points2.push({x:x + standP.x + brushSize*0.5 ,y: y + standP.y - brushSize*0.5});
                        // drawPoint(points2[i].x,points2[i].y,"rgba(255,0,0,1)");
                    }

                    for(var i =0, n=points1.length; i<n; i++){
                        // drawLine(points1[i],points2[i],"rgba(0,0,255,1)");
                        drawPoints.push(points1[i]);
                        drawPoints.push(points2[i]);
                    }

                    brushDrawStart();
                }

                function drawPoint(x,y,color){
                    ctx2.save();
                    ctx2.fillStyle = color;
                    ctx2.beginPath();
                    ctx2.arc(x, y, 2, 0, 360*Math.PI/180, true);
                    ctx2.closePath();
                    ctx2.fill();
                    ctx2.restore();
                }

                function drawLine(start,last,color){
                    ctx2.save();
                    ctx2.strokeStyle = color;
                    ctx2.beginPath();
                    ctx2.moveTo(start.x,start.y);
                    ctx2.lineTo(last.x, last.y);
                    ctx2.stroke();
                    ctx2.restore();
                }

                function drawRect(x,y,width,height){
                    ctx2.save();
                    ctx2.fillStyle = "rgba(0,0,255,.5)";
                    ctx2.beginPath();
                    ctx2.fillRect(x,y,width,height);
                    ctx2.beginPath();
                    ctx2.fill();
                    ctx2.restore();
                }
                
                $(canvas).bind(canvas.EVENT_CHANGE,function(e,data){
                    if(data.type == 'ready'){
                        // canvas.start();

                        ctx.save();
                        ctx.fillStyle = 'fff4ed';
                        ctx.fillRect(standP.x,standP.y,drawImg.width,drawImg.height);
                        ctx.restore();
                        canvas.drawImage(drawImg,standP.x,standP.y);

                        ctx.globalCompositeOperation = 'destination-out';
                    };
                });


                var sketchPowder,colorData;
                $(canvas2).bind(canvas.EVENT_CHANGE,function(e,data){
                    if(data.type == 'ready'){
                        // canvas2.start();
                        // canvas2.drawImage(drawImg,300,200);
                        // sketchPowder    = new SketchPowder(canvas2);
                        // colorData = canvas2.getImageData({x:300,y:200,width:drawImg.width,height:drawImg.height});
                        // canvas2.clear();
                        // var cvs = canvas2.getCanvas();
                        // $(cvs).bind("mousemove",onMousemove);
                        // $(cvs).bind("mousedown",onMousedown);
                        // $(cvs).bind("mouseup",onMouseup);

                        // ctx.save();
                        // ctx.fillStyle = 'rgba(255,0,0,1)';
                        // ctx.fillRect(0,0,ctx.width,ctx.height);
                        // ctx.restore();
                    }
                });


                canvas.draw = function(ctx){
                    
                }

                canvas2.draw = function(ctx){
                    // canvas2.clear();
                    // sketchPowder.draw();
                    // canvas2.drawImage(drawImg,300,200);
                    // if (!isDrawing) return;
                    
                    // var info = {};

                    // for(var i = 0 ; i < 10; i++){
                    //     var cx = drawPos.x+10-(i%10)+20,
                    //         cy = drawPos.y+10-(i%10)+20;

                    //     if(colorData.data[cx] && colorData.data[cx][cy]){
                    //         info = { color:colorData.data[cx][cy] };
                    //         // sketchPowder.make(cx,cy,info);
                    //     }    
                    // }
                }

                var brushPos = {sp:{x:0,y:0},lp:{x:0,y:0}},
                    drawPos  = {x:0,y:0},
                    brushCnt = 0,
                    startTime,crtTime,lastPoint = {x:0,y:0};
                function brushDrawStart(){
                    for(var i=0; i<drawPoints.length-1; i++){
                        animateStep(i,800,150,false);
                        animateStep(i,1000,200,true);
                    }

                    
                }


                function animateStep(i,duration,delay,detail){
                    var now     = drawPoints[i],
                        target  = drawPoints[i+1];

                    $({x:now.x,y:now.y}).stop().delay(i*delay).animate({x:target.x,y:target.y}, {    
                        duration    : duration,
                        step        : function(now,fx){
                            var p = fx.elem;
                            drawPos.x = p.x;
                            drawPos.y = p.y;
                            // ctx.drawImage(brush, p.x, p.y);
                            brushDraw(drawPos,detail);
                        },
                        complete    : function(){
                            // brushCnt++;
                            // if(brushCnt < drawPoints.length-1){
                                // brushDrawStart();
                            // }
                        },
                        easing      : "easeOutQuint"
                    });
                }


                var isDrawing = false,
                    x,y;


                function brushDraw(pos,detail){
                    dist    = distanceBetween(lastPoint, drawPos);
                    angle   = angleBetween(lastPoint, drawPos);

                    ctx.drawImage(brush, pos.x-brushSize*0.5, pos.y-brushSize*0.5);

                    if(detail){
                        for (var i = 0; i < dist; i++) {
                            x = parseInt(lastPoint.x + (Math.sin(angle) * i)-brushSize);
                            y = parseInt(lastPoint.y + (Math.cos(angle) * i)-brushSize);
                            ctx.drawImage(brush, x, y);
                        }

                    }

                    lastPoint.x = x;
                    lastPoint.y = y;
                }
                

                function onMousemove(e){
                    if (!isDrawing) return;
                    // canvas.drawImage(img,300,200);
                    // var mouse = { x:e.clientX, y:e.clientY};
                    // if(sketchPowder){
                    //     sketchPowder.mouse.crt = mouse;
                    // }

                    // currentPoint = { x: e.clientX, y: e.clientY };
                    // dist = distanceBetween(lastPoint, currentPoint);
                    // angle = angleBetween(lastPoint, currentPoint);
                    // // ctx.globalCompositeOperation = 'destination-out';

                    // for (var i = 0; i < dist; i++) {
                    //     x = parseInt(lastPoint.x + (Math.sin(angle) * i) - 20);
                    //     y = parseInt(lastPoint.y + (Math.cos(angle) * i) - 20);
                    //     ctx.drawImage(brush, x, y);
                    // }


                    
                    // lastPoint = currentPoint;
                }

                function onMousedown(e){
                    // isDrawing = true;
                    // x = e.clientX;
                    // y = e.clientY;
                    // lastPoint = { x: e.clientX, y: e.clientY };
                }

                function onMouseup(){
                    isDrawing = false;
                }

                function distanceBetween(point1, point2) {
                  return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
                }
                function angleBetween(point1, point2) {
                  return Math.atan2( point2.x - point1.x, point2.y - point1.y );
                }
            });
             
        </script>
    </head>
    <body> 
        <img id="img-color2" src="img/img1-sketch.png" style="position:absolute; displey:hidden; opacity:0">
        <img id="img-color" src="img/img1.png" alt="">
        <!-- <img id="img-color" src="img/01-grey.png" alt=""> -->
        <div id="canvasWrap"></div>
        <div id="canvasWrap2"></div>
    </body>
</html>



<!--  
 HTMLCanvasElement

    toDataURL()
    getContext()

 メソッド
    addColorStop()
    arc()
    arcTo()
    beginPath()
    bezierCurveTo()
    clearRect()
    clip()
    closePath()
    createImageData()
    createLinearGradient()
    createPattern()
    createRadialGradient()
    drawFocusRing()
    drawImage()
    fill()
    fillRect()
    fillText()
    getImageData()
    isPointInPath()
    lineTo()
    measureText()
    moveTo()
    putImageData()
    quadraticCurveTo()
    rect()
    restore()
    rotate()
    save()
    scale()
    setTransform()
    stroke()
    strokeRect()
    strokeText()
    translate()
    transform()

プロパティ
    fillStyle
    font
    globalAlpha
    globalCompositeOperation
    lineCap
    lineJoin
    lineWidth
    miterLimit
    shadowBlur
    shadowColor
    shadowOffsetX
    shadowOffsetY
    strokeStyle
    textAlign
    textBaseline
 */

 -->